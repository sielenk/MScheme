package mscheme;

public interface Init
{
    String bootstrap = "(begin(define update-null-environment(let()(define(make-promise proc)(let((result-ready? #f)(result #f))(lambda()(if result-ready? result(let((x(proc)))(if result-ready? result(begin(set! result-ready? #t)(set! result x)result)))))))(define(delay-func def-env use-env expression)(list make-promise(list 'lambda '()expression)))(define(wrapper func)(lambda(def-env use-env . args)(cons use-env(apply func def-env use-env args))))(lambda(env)(eval(list 'begin(list 'define-syntax 'delay(wrapper delay-func)))env)env)))(update-null-environment machine-environment)(define(reduce func initial args)(if(null? args)initial(let helper([head(car args)][tail(cdr args)])(if(null? tail)head(helper(func head(car tail))(cdr tail))))))(define(reduce-right func initial args)(if(null? args)initial(let helper([head(car args)][tail(cdr args)])(if(null? tail)head(func head(helper(car tail)(cdr tail)))))))(define(fold-right func initial args)(if(null? args)initial(let helper([head(car args)][tail(cdr args)])(func head(if(null? tail)initial(helper(car tail)(cdr tail)))))))(define(fold-left func initial args)(let helper([head initial][tail args])(if(null? tail)head(helper(func head(car tail))(cdr tail)))))(define update-scheme-report-environment(let()(define(time f . args)(ticker)(let*((result(apply f args))(t(ticker)))(cons result(- t 11))))(define(caar x)(car(car x)))(define(cadr x)(car(cdr x)))(define(cdar x)(cdr(car x)))(define(cddr x)(cdr(cdr x)))(define(caaar x)(car(car(car x))))(define(caadr x)(car(car(cdr x))))(define(cadar x)(car(cdr(car x))))(define(caddr x)(car(cdr(cdr x))))(define(cdaar x)(cdr(car(car x))))(define(cdadr x)(cdr(car(cdr x))))(define(cddar x)(cdr(cdr(car x))))(define(cdddr x)(cdr(cdr(cdr x))))(define(caaaar x)(car(car(car(car x)))))(define(caaadr x)(car(car(car(cdr x)))))(define(caadar x)(car(car(cdr(car x)))))(define(caaddr x)(car(car(cdr(cdr x)))))(define(cadaar x)(car(cdr(car(car x)))))(define(cadadr x)(car(cdr(car(cdr x)))))(define(caddar x)(car(cdr(cdr(car x)))))(define(cadddr x)(car(cdr(cdr(cdr x)))))(define(cdaaar x)(cdr(car(car(car x)))))(define(cdaadr x)(cdr(car(car(cdr x)))))(define(cdadar x)(cdr(car(cdr(car x)))))(define(cdaddr x)(cdr(car(cdr(cdr x)))))(define(cddaar x)(cdr(cdr(car(car x)))))(define(cddadr x)(cdr(cdr(car(cdr x)))))(define(cdddar x)(cdr(cdr(cdr(car x)))))(define(cddddr x)(cdr(cdr(cdr(cdr x)))))(define(primitve-map f l)(fold-right(lambda(x r)(cons(f x)r))'()l))(define(transpose lists)(let loop((rest lists))(if(null?(car rest))'()(cons(primitve-map car rest)(loop(primitve-map cdr rest))))))(define(map func . lists)(if(null?(cdr lists))(primitve-map func(car lists))(primitve-map(lambda(list)(apply func list))(transpose lists))))(define(for-each func . lists)(reverse(apply map func(map reverse lists))))(define(force object)(object))(define(call-with-input-file filename proc)(let*((port(open-input-file filename))(result(proc port)))(close-input-port port)result))(define(call-with-output-file filename proc)(let*((port(open-output-file filename))(result(proc port)))(close-output-port port)result))(define with-input-from-file 'dummy)(define with-output-to-file 'dummy)(define dynamic:winds '())(define(dynamic-wind thunk1 thunk2 thunk3)(thunk1)(set! dynamic:winds(cons(cons thunk1 thunk3)dynamic:winds))(let([result(thunk2)])(set! dynamic:winds(cdr dynamic:winds))(thunk3)result))(define(dynamic:do-winds to delta)(if(not(eq? dynamic:winds to))(if(< delta 0)(begin(dynamic:do-winds(cdr to)(+ 1 delta))((caar to))(set! dynamic:winds to))(let((from(cdar dynamic:winds)))(set! dynamic:winds(cdr dynamic:winds))(from)(dynamic:do-winds to(+ -1 delta))))))(define dynamic:call-cc call-with-current-continuation)(set! call-with-current-continuation(lambda(proc)(let((winds dynamic:winds))(dynamic:call-cc(lambda(cont)(proc(lambda(c2)(dynamic:do-winds winds(-(length dynamic:winds)(length winds)))(cont c2))))))))(let([basic-read read][basic-read-char read-char][basic-peek-char peek-char][basic-char-ready? char-ready?][basic-write write][basic-display display][basic-write-char write-char][basic-null-environment null-environment][basic-scheme-report-environment scheme-report-environment])(define(wrap-cip func)(lambda args(if(null? args)(func(current-input-port))(apply func args))))(define(wrap-cop func)(lambda(obj . args)(if(null? args)(func obj(current-output-port))(apply func obj args))))(let([read(wrap-cip basic-read)][read-char(wrap-cip basic-read-char)][peek-char(wrap-cip basic-peek-char)][char-ready?(wrap-cip basic-char-ready?)][write(wrap-cop basic-write)][display(wrap-cop basic-display)][write-char(wrap-cop basic-write-char)])(define with-input-from-file(lambda(filename thunk)(call-with-input-file filename(lambda(new-cip)(let([old-cip(current-input-port)])(dynamic-wind(lambda()(reset-input-port new-cip))thunk(lambda()(reset-input-port old-cip))))))))(define with-output-to-file(lambda(filename thunk)(call-with-output-file filename(lambda(new-cop)(let([old-cop(current-output-port)])(dynamic-wind(lambda()(reset-output-port new-cop))thunk(lambda()(reset-output-port old-cop))))))))(define(newline . args)(apply display #\\newline args))(define(make-load env)(lambda(filename)(let([port(open-input-file filename)])(let eval-expr([expr(read port)][result '()])(if(eof-object? expr)result(eval-expr(read port)(eval expr env)))))))(define(null-environment version)(update-null-environment(basic-null-environment version)))(define(scheme-report-environment version)(update-scheme-report-environment(update-null-environment(basic-scheme-report-environment version))))(let([definition-list(cons 'begin(map(lambda(p)(list 'define(car p)(cdr p)))(list(cons 'time time)(cons 'caar caar)(cons 'cadr cadr)(cons 'cdar cdar)(cons 'cddr cddr)(cons 'caaar caaar)(cons 'caadr caadr)(cons 'cadar cadar)(cons 'caddr caddr)(cons 'cdaar cdaar)(cons 'cdadr cdadr)(cons 'cddar cddar)(cons 'cdddr cdddr)(cons 'caaaar caaaar)(cons 'caaadr caaadr)(cons 'caadar caadar)(cons 'caaddr caaddr)(cons 'cadaar cadaar)(cons 'cadadr cadadr)(cons 'caddar caddar)(cons 'cadddr cadddr)(cons 'cdaaar cdaaar)(cons 'cdaadr cdaadr)(cons 'cdadar cdadar)(cons 'cdaddr cdaddr)(cons 'cddaar cddaar)(cons 'cddadr cddadr)(cons 'cdddar cdddar)(cons 'cddddr cddddr)(cons 'dynamic-wind dynamic-wind)(cons 'call-with-current-continuation call-with-current-continuation)(cons 'map map)(cons 'for-each for-each)(cons 'force force)(cons 'call-with-input-file call-with-input-file)(cons 'call-with-output-file call-with-output-file)(cons 'current-input-port current-input-port)(cons 'current-output-port current-output-port)(cons 'with-input-from-file with-input-from-file)(cons 'with-output-to-file with-output-to-file)(cons 'read read)(cons 'read-char read-char)(cons 'peek-char peek-char)(cons 'char-ready? char-ready?)(cons 'write write)(cons 'display display)(cons 'write-char write-char)(cons 'newline newline)(cons 'null-environment null-environment)(cons 'scheme-report-environment scheme-report-environment))))])(lambda(env)(eval definition-list env)(eval(list 'define 'load(make-load env))env)env))))))(update-scheme-report-environment machine-environment))";

    String rep = "(let*((user-env(scheme-report-environment 5))(user-eval(lambda(expr)(eval expr user-env)))(user-define(lambda(sym val)(user-eval(list 'define sym val))))(user-load(user-eval 'load)))(define error->cause car)(define error->message cadr)(define error->continuation caddr)(define error->retryable cadddr)(define(display-nl . args)(for-each display args)(newline))(define(print-error error)(let((cause(error->cause error))(message(error->message error))(stack(error->continuation error)))(display-nl \"error : \" message)(display \"caused by : \")(write cause)(newline)(display-nl \"--- begin of stack ---\")(display-nl stack)(display-nl \"--- end of stack ---\")))(define(try-with-error-handler try-thunk error-handler)(let*((old-handler(reset-error-handler(lambda(error)(print-error error)(error-handler error))))(result(try-thunk)))(reset-error-handler old-handler)result))(define(create-label)(call-with-current-continuation(lambda(k)(define(label)(k label))label)))(define(retry-on-error thunk)(define retry(create-label))(try-with-error-handler thunk(lambda(error)(retry))))(define(REP-read depth prompt quit-thunk)(let*((query(lambda()(if prompt(begin(if(> depth 0)(begin(display #\\[)(display depth)(display #\\])))(prompt)))(read)))(input(retry-on-error query)))(if(eof-object? input)(begin(display-nl \"<Ctrl-D>\")(quit-thunk))input)))(define(REP-eval error-REP expr)(call-with-current-continuation(lambda(return)(try-with-error-handler(lambda()(user-eval expr))(lambda(error)(if(error->retryable error)(begin(display-nl \"press Ctrl-D to return to outer REP\")((error->continuation error)(error-REP)))(return '<error>)))))))(define(REP-print expr)(write expr)(newline)expr)(define(REP prompt)(let internal-REP((level 0))(call-with-current-continuation(lambda(quit)(let loop((result #f))(loop(REP-print(REP-eval(lambda()(internal-REP(+ level 1)))(REP-read level prompt(lambda()(quit result)))))))))))(display-nl \"Welcome to MScheme\")(display-nl \"press Ctrl-D to quit\")(REP(lambda()(display \"--> \")))(display-nl \"bye ... \"))";

}
